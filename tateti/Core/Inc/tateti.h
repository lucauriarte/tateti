/* Generated by itemis CREATE code generator. */

#ifndef TATETI_H_
#define TATETI_H_

#ifdef __cplusplus
extern "C" { 
#endif

/*!
* Forward declaration for the Tateti state machine.
*/
typedef struct Tateti Tateti;

/*!
* Forward declaration of the data structure for the TatetiIface interface scope.
*/
typedef struct TatetiIface TatetiIface;

#ifdef __cplusplus
}
#endif

#include "sc_types.h"

#ifdef __cplusplus
extern "C" { 
#endif 

/*! \file
Header of the state machine 'tateti'.
*/

#ifndef TATETI_EVENTQUEUE_BUFFERSIZE
#define TATETI_EVENTQUEUE_BUFFERSIZE 20
#endif
#ifndef TATETI_IN_EVENTQUEUE_BUFFERSIZE
#define TATETI_IN_EVENTQUEUE_BUFFERSIZE TATETI_EVENTQUEUE_BUFFERSIZE
#endif
#ifndef SC_INVALID_EVENT_VALUE
#define SC_INVALID_EVENT_VALUE 0
#endif
/*! Define number of states in the state enum */
#define TATETI_STATE_COUNT 5

/*! Define dimension of the state configuration vector for orthogonal states. */
#define TATETI_MAX_ORTHOGONAL_STATES 1

/*! Define indices of states in the StateConfVector */
#define SCVI_TATETI_MAIN_REGION_IDLE 0
#define SCVI_TATETI_MAIN_REGION_PLAYING 0
#define SCVI_TATETI_MAIN_REGION_CHECK_WIN 0
#define SCVI_TATETI_MAIN_REGION_MATCH_END 0
#define SCVI_TATETI_MAIN_REGION_GAME_OVER 0

/*
 * Union of all possible event value types.
 */
typedef union {
	sc_integer Tateti_key_pressed_value;
} tateti_event_value;

/* 
 * Enum of event names in the statechart.
 */
typedef enum  {
	Tateti_invalid_event = SC_INVALID_EVENT_VALUE,
	Tateti_key_pressed
} TatetiEventID;

/*
 * Struct that represents a single event.
 */
typedef struct {
	TatetiEventID name;
	sc_boolean has_value;
	tateti_event_value value;
} tateti_event;

/*
 * Queue that holds the raised events.
 */
typedef struct tateti_eventqueue_s {
	tateti_event *events;
	sc_integer capacity;
	sc_integer pop_index;
	sc_integer push_index;
	sc_integer size;
} tateti_eventqueue;

/*! Enumeration of all states */ 
typedef enum
{
	Tateti_last_state,
	Tateti_main_region_Idle,
	Tateti_main_region_Playing,
	Tateti_main_region_Check_win,
	Tateti_main_region_Match_end,
	Tateti_main_region_Game_over
} TatetiStates;


/*! Type declaration of the data structure for the TatetiIface interface scope. */
struct TatetiIface
{
	sc_boolean key_pressed_raised;
	sc_integer key_pressed_value;
	sc_integer current_player;
	sc_integer p1_score;
	sc_integer p2_score;
	sc_integer winner;
	sc_integer win_type;
};








/*! 
 * Type declaration of the data structure for the Tateti state machine.
 * This data structure has to be allocated by the client code. 
 */
struct Tateti
{
	TatetiStates stateConfVector[TATETI_MAX_ORTHOGONAL_STATES];
	TatetiIface iface;
	sc_boolean completed;
	sc_boolean doCompletion;
	sc_boolean isExecuting;
	tateti_eventqueue in_event_queue;
	tateti_event in_buffer[TATETI_IN_EVENTQUEUE_BUFFERSIZE];
};



/*! Initializes the Tateti state machine data structures. Must be called before first usage.*/
extern void tateti_init(Tateti* handle);


/*! Activates the state machine. */
extern void tateti_enter(Tateti* handle);

/*! Deactivates the state machine. */
extern void tateti_exit(Tateti* handle);

/*! 
Can be used by the client code to trigger a run to completion step without raising an event.
*/
extern void tateti_trigger_without_event(Tateti* handle);



/*! Raises the in event 'key_pressed' that is defined in the default interface scope. */ 
extern void tateti_raise_key_pressed(Tateti* handle, sc_integer value);
/*! Gets the value of the variable 'current_player' that is defined in the default interface scope. */ 
extern sc_integer tateti_get_current_player(const Tateti* handle);
/*! Sets the value of the variable 'current_player' that is defined in the default interface scope. */ 
extern void tateti_set_current_player(Tateti* handle, sc_integer value);
/*! Gets the value of the variable 'p1_score' that is defined in the default interface scope. */ 
extern sc_integer tateti_get_p1_score(const Tateti* handle);
/*! Sets the value of the variable 'p1_score' that is defined in the default interface scope. */ 
extern void tateti_set_p1_score(Tateti* handle, sc_integer value);
/*! Gets the value of the variable 'p2_score' that is defined in the default interface scope. */ 
extern sc_integer tateti_get_p2_score(const Tateti* handle);
/*! Sets the value of the variable 'p2_score' that is defined in the default interface scope. */ 
extern void tateti_set_p2_score(Tateti* handle, sc_integer value);
/*! Gets the value of the variable 'winner' that is defined in the default interface scope. */ 
extern sc_integer tateti_get_winner(const Tateti* handle);
/*! Sets the value of the variable 'winner' that is defined in the default interface scope. */ 
extern void tateti_set_winner(Tateti* handle, sc_integer value);
/*! Gets the value of the variable 'win_type' that is defined in the default interface scope. */ 
extern sc_integer tateti_get_win_type(const Tateti* handle);
/*! Sets the value of the variable 'win_type' that is defined in the default interface scope. */ 
extern void tateti_set_win_type(Tateti* handle, sc_integer value);

/*!
 * Checks whether the state machine is active (until 2.4.1 this method was used for states).
 * A state machine is active if it was entered. It is inactive if it has not been entered at all or if it has been exited.
 */
extern sc_boolean tateti_is_active(const Tateti* handle);

/*!
 * Checks if all active states are final. 
 * If there are no active states then the state machine is considered being inactive. In this case this method returns false.
 */
extern sc_boolean tateti_is_final(const Tateti* handle);

/*! Checks if the specified state is active (until 2.4.1 the used method for states was called isActive()). */
extern sc_boolean tateti_is_state_active(const Tateti* handle, TatetiStates state);


#ifdef __cplusplus
}
#endif 

#endif /* TATETI_H_ */
